# 设计模式

设计模式，有助于写出可复用和可维护性高的程序；

### 一、单例模式

保证一个类只有一个实例，并提供一个访问它的全局访问点；

### 二、策略模式

定义一系列算法，把它们封装起来，并且使它们可以相互替换。

核心：将算法的使用和算法的实现分离开来；

一组策略类和环境类；

### 三、代理模式

为一个对象提供一个代用品或占位符，以便控制对它的访问。

当客户不方便直接访问一个 对象或者不满足需要的时候，提供一个替身对象 来控制对这个对象的访问，客户实际上访问的是 替身对象。

替身对象对请求做出一些处理之后， 再把请求转交给本体对象；

保护代理、虚拟代理、缓存代理；

过滤字符；节流；

### 四、迭代器模式

提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。

在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。

forEach 、map ；



### 五、发布-订阅模式

也称观察者模式，定义以对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。

一个对象不再显示地调用另一个对象的某个接口。

JavaScript通常使用注册回调函数的形式来订阅。

这里的“询问”属于显示调用，“留给”属于订阅，“通知”属于发布

### 六、命令模式

命令指的是一个执行某些特定事情的指令；



### 七、组合模式

用小的对象来构建更大的对象，而这些小的对象本身也许由更小的对象构成；

组合模式不是父子关系，它是一种HAS-A（聚合）的关系，将请求委托给 它所包含的所有叶对象。基于这种委托，就需要保证组合对象和叶对象拥有相同的 接口

此外，也要保证用一致的方式对待 列表中的每个叶对象，即叶对象属于同一类，不需要过多特殊的额外操作

### 八、模板方法模式



### 九、享元模式

一种用于性能优化的模式，目标是尽量减少共享对象的数量；

### 十、职责链模式

使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止；

### 十一、中介者模式

所有的相关 对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可

### 十二、装饰者模式

以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。

是一种“即用即付”的方式，能够在不改变对 象自身的基础上，在程序运行期间给对象动态地 添加职责。

### 十三、状态模式

事物内部状态的改变往往会带来事物的行为改变。在处理的时候，将这个处理委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为

### 十四、适配器模式

解决两个软件实体之间的接口不兼容的问题，对不兼容的部分进行适配；

### 十五、外观模式

为子系统中的一组接口提供一个一致的界面，定义一个高层接口，使得子系统更加容易使用；



### 工厂模式

工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。





















